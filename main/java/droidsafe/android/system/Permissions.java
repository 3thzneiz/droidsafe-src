package droidsafe.android.system;

import java.io.File;
import java.io.FileReader;
import java.io.LineNumberReader;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import soot.Hierarchy;
import soot.Scene;
import soot.SootMethod;
import droidsafe.main.Config;
import droidsafe.utils.SootUtils;

/**
 * This class stores information and queries regarding permissions in the Android API 
 * version 15.  It allows one to query the permission a method might require, and the 
 * other permission mappings like URIs and Intents.
 * 
 * The underlying information was generated by the PScout Tool.
 * 
 * @author mgordon
 *
 */
public class Permissions {
	private final static Logger logger = LoggerFactory.getLogger(Permissions.class);
	
	private static Permissions v;
	
	Map<SootMethod, Set<String>> methodToPerms;
	
	private final String METHOD_PERMS_FILE = "method-permissions.txt";
	private final String PERM_DIR = "config-files" + File.separator + "permissions";
	
	public static void init() {
		v = new Permissions();
	}
	
	private Permissions() {
		soot.Hierarchy h = new soot.Hierarchy();
		methodToPerms = new LinkedHashMap<SootMethod, Set<String>>();
		readMethodPerms(h);
		//read method and their permissions

		//read intents with permissions

		//read uri strings with permissions

		//ready uri field with permissions
	}

	/**
	 * Given a method signature return the set of permissions it may require 
	 * at runtime.  
	 */
	public Set<String> getPermissions(SootMethod method) {
		if (methodToPerms.containsKey(method)) 
			return methodToPerms.get(method);
		else
			return Collections.EMPTY_SET;
	}

	private void readMethodPerms(Hierarchy h) {
		File file= new File(Config.v().getApacHome() + File.separator + PERM_DIR + 
				File.separator + METHOD_PERMS_FILE);
		try {
			LineNumberReader br = new LineNumberReader (new FileReader (file));

			String line = null;
			int line_num = 0;

			Pattern startPermission = Pattern.compile("Permission:(\\S+)");
			String currentPermission = null;
			
			while ((line = br.readLine()) != null) {
				line_num = br.getLineNumber();
				line = line.trim();
				
				Matcher start = startPermission.matcher(line);
				
				if (start.find()) {
					currentPermission = start.group(1);
				} else {
					SootMethod method = isMethodLine(line, h);
					if (method != null) {
						if (currentPermission == null) 
							logger.error("Error reading permissions file");
						
						if (!methodToPerms.containsKey(method))
							methodToPerms.put(method, new LinkedHashSet<String>());
						
						methodToPerms.get(method).add(currentPermission);
						//logger.info("{} requires permission {}", method, currentPermission);
					}
				}
				
			}
		} catch (Exception e) {
			logger.error("During reading method permission file.", e);
		}
	}

	/**
	 * If we have a method line, return the method otherwise null.
	 */
	private SootMethod isMethodLine(String line, soot.Hierarchy h) {
		Pattern sigRE = Pattern.compile("<\\S+: \\S+ \\S+\\(.*\\)>");
		Matcher matcher = sigRE.matcher(line);
		boolean b = matcher.find();
		
		if (!b)
			return null;
		
		String sig = matcher.group();
		
		if (Scene.v().containsMethod(sig)) {
			return Scene.v().getMethod(sig);
		} else { 
			try {
				return 
						SootUtils.resolveMethod(Scene.v().getSootClass(SootUtils.grabClass(sig)), sig);
			} catch (Exception e) {
				//the list of method from pscout includes libraries that we do not cover!
				//so if we are searching for a method, it might throw an exception if the class
				//is not in the scene...
			}
		}
		return null;
	}
	
	public static Permissions v() {
		return v;
	}
}
