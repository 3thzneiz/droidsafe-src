/*
 * Copyright (C) 2015,  Massachusetts Institute of Technology
 * 
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation; either version 2 of the License, or (at your
 * option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * for more details.
 * 
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc., 
 * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 * 
 * Please email droidsafe@lists.csail.mit.edu if you need additional
 * information or have any questions.
 */

package droidsafe.transforms.objsensclone;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Comparator;

import org.apache.commons.lang3.text.translate.NumericEntityUnescaper.OPTION;
import org.jgrapht.ext.DOTExporter;
import org.jgrapht.ext.VertexNameProvider;
import org.jgrapht.graph.DefaultDirectedWeightedGraph;
import org.jgrapht.graph.DefaultWeightedEdge;
import org.jgrapht.graph.DirectedMultigraph;
import org.jgrapht.graph.DirectedWeightedMultigraph;
import org.jgrapht.traverse.BreadthFirstIterator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import droidsafe.analyses.pta.PTABridge;
import droidsafe.android.app.Project;
import droidsafe.android.system.API;
import droidsafe.main.Config;
import droidsafe.utils.MutableInt;
import droidsafe.utils.SootUtils;
import soot.Body;
import soot.RefType;
import soot.Scene;
import soot.SootClass;
import soot.SootMethod;
import soot.Value;
import soot.ValueBox;
import soot.jimple.AssignStmt;
import soot.jimple.NewArrayExpr;
import soot.jimple.NewExpr;
import soot.jimple.Stmt;
import soot.jimple.StmtBody;
import soot.jimple.StringConstant;
import soot.options.Options;
import soot.util.Chain;

/**
 * A graph representing the allocation of a program.  Nodes are classes, and an edge from 
 * A->B denotes that class A creates a class B.  
 * 
 * The graph is used to clone classes in a particular order and introduce object sensitivity.
 * 
 * There are a few different methods that calculate different orderings for cloning.
 * 
 * @author mgordon
 *
 */
public class AllocationGraph {
	/** static logger class */
	private static final Logger logger = LoggerFactory.getLogger(AllocationGraph.class);
	/** the graph of allocation built on top of jgrapht. */
	private DirectedWeightedMultigraph<SootClass, DefaultWeightedEdge> graph;
	/** set of edges in the graph that are generated by static methods */
	private Set<DefaultWeightedEdge> staticEdges;
	/** map of soot class to the new expressions in reachable code that allocates the class */
	private Map<SootClass, Set<NewExpr>> classToNewExprs;
	/** map of class to number of new array expressions in reachable methods */    
	private Map<SootClass, MutableInt> reachableNewArrayExprs;
	/** map of class to string constants in reachable methods */    
	private Map<SootClass, Set<String>> reachableStringConsts;
	private Map<SootClass, Long> complexityMap;
	private Map<SootClass,Integer> staticSelfAllocations;
	private Map<SootClass,Integer> virtualSelfAllocations;

	private static AllocationGraph v;

	public static AllocationGraph v() {		
		return v;
	}

	public static void update() {
		v = new AllocationGraph();
	}

	/**
	 * Create an allocation graph based on the current classes in the scene.
	 */
	public AllocationGraph() {
		graph = new DirectedWeightedMultigraph<SootClass, DefaultWeightedEdge>(DefaultWeightedEdge.class);
		staticEdges = new HashSet<DefaultWeightedEdge>();
		classToNewExprs = new HashMap<SootClass, Set<NewExpr>>();
		reachableNewArrayExprs = new HashMap<SootClass, MutableInt>();
		reachableStringConsts = new HashMap<SootClass, Set<String>>();
		complexityMap = new HashMap<SootClass, Long>();
		staticSelfAllocations = new HashMap<SootClass,Integer>();
		virtualSelfAllocations = new HashMap<SootClass,Integer>();
		buildAllocationGraph();
		createComplexityMap();


		/*exportToDot(Project.v().getOutputDir() + File.separator + 
            "allocation-graph.dot");*/

		//System.out.println("Allocation graph size: " + graph.vertexSet().size());

		/*
        for (SootClass clz : workList()) {
            System.out.println(clz);
        }

        System.out.println("*************");
		 */
	}

	/**
	 * @return The total complexity of all classes.
	 */
	public long getTotalComplexity() {
		long total = 0;

		for (Map.Entry<SootClass, Long> entry : complexityMap.entrySet()) {
			total += entry.getValue();
		}

		return total;
	}

	private int getArrayAndStringConstComplexity(SootClass clz) {
		return (reachableStringConsts.get(clz) == null ? 0 :
			reachableStringConsts.get(clz).size()) +
				(reachableNewArrayExprs.get(clz) == null ? 0 :
					reachableNewArrayExprs.get(clz).value());

	}

	private long calcNumberOfContexts(SootClass current, int distanceFromStart, int k) {
		if (distanceFromStart == k) 
			return 1;

		if (distanceFromStart > k) {
			throw new RuntimeException("Should never happen");
		}		

		long sum = 0;

		for (DefaultWeightedEdge edge : graph.incomingEdgesOf(current)) {
			SootClass source = graph.getEdgeSource(edge);			
			if (staticEdges.contains(edge)) {
				//static edge
				sum += graph.getEdgeWeight(edge);
			} else {
				//non-static edge
				//call recursively on parent
				//System.out.println("Virtual " + edge + " " + graph.getEdgeWeight(edge));
				sum += (calcNumberOfContexts(source, distanceFromStart + 1, k) * graph.getEdgeWeight(edge));
			}
		}

		//static self creations
		if (staticSelfAllocations.containsKey(current))
			sum += staticSelfAllocations.get(current);

		//virtual self creations, reduce count self creations by assuming loops through allocation node
		if (virtualSelfAllocations.containsKey(current)) { 
			long numberOfContextAfterSelfCreations = 0;
			for (int selfDistance = distanceFromStart + 2; selfDistance <= k; selfDistance++) {
				for (DefaultWeightedEdge edge : graph.incomingEdgesOf(current)) {
					SootClass source = graph.getEdgeSource(edge);			
					if (staticEdges.contains(edge)) {
						//static edge
						numberOfContextAfterSelfCreations += graph.getEdgeWeight(edge);
					} else {
						//non-static edge
						//call recursively on parent
						numberOfContextAfterSelfCreations += (calcNumberOfContexts(source, selfDistance, k) * graph.getEdgeWeight(edge));
					}
				}
			}


			sum += (numberOfContextAfterSelfCreations * virtualSelfAllocations.get(current));
		}

		//account for entry points, with no incoming edges		
		if (sum == 0)
			sum = 1;

		return sum;
	}

	private long calcComplexity(SootClass clz) {
		return  calcNumberOfContexts(clz, 0, Config.v().kobjsens);
	}


	public Long getComplexity(SootClass clz) {
		return complexityMap.get(clz);
	}

	public Map<SootClass, Long> getComplexityMap() {
		return complexityMap;
	}

	private void createComplexityMap() {
		for (SootClass clz : graph.vertexSet()) {
			complexityMap.put(clz, calcComplexity(clz));                
		}
	}

	public void dumpComplexity() {
		try (FileWriter fw = new FileWriter(Project.v().getOutputDir() + File.separator + "alloc-complexity.csv")){
			for (SootClass clz : graph.vertexSet()) {
				fw.write(clz + "," + complexityMap.get(clz) + "\n");                
			}

		} catch (IOException e) {

		}
	}

	private void updateAllocationGraph(SootMethod method) {
		if (method.isAbstract() || !method.isConcrete())
			return;

		SootClass enclosingClass = method.getDeclaringClass();

		boolean debug = ("<com.example.android.apis.content.PickContact: void onCreate(android.os.Bundle)>".equals(method.getSignature()));

		Body body = method.getActiveBody();
		StmtBody stmtBody = (StmtBody)body;
		Chain units = stmtBody.getUnits();
		Iterator stmtIt = units.snapshotIterator();

		while (stmtIt.hasNext()) {
			Stmt stmt = (Stmt)stmtIt.next();

			if (stmt instanceof AssignStmt) {
				AssignStmt assign = (AssignStmt) stmt;
				if (assign.getRightOp() instanceof NewExpr) {
					NewExpr newExpr = (NewExpr)assign.getRightOp();
					SootClass newClass = newExpr.getBaseType().getSootClass();
					//is exception?
					if (!SootUtils.isSubTypeOfIncluding(RefType.v(newClass), RefType.v("java.lang.Throwable"))) {                  
						graph.addVertex(enclosingClass);
						graph.addVertex(newClass);						
						if (newClass.equals(enclosingClass)) {
							//self creation
							Map<SootClass,Integer> selfAllocations;
							if (method.isStatic()) {
								selfAllocations = staticSelfAllocations;
							} else {
								selfAllocations = virtualSelfAllocations;
							}

							if (!selfAllocations.containsKey(enclosingClass)) {
								selfAllocations.put(enclosingClass, 0);
							}

							selfAllocations.put(enclosingClass, selfAllocations.get(enclosingClass) + 1);

						} else {
							//not self creation, create edges

							//there can be at most 2 edges between any two nodes, one for 
							//new expressions in virtual methods, and one for new expression in static methods
							if (method.isStatic()) {
								Set<DefaultWeightedEdge> edges = graph.getAllEdges(enclosingClass, newClass);
								DefaultWeightedEdge existingStaticEdge = null;
								for (DefaultWeightedEdge edge : edges) {
									if (staticEdges.contains(edge)) {
										existingStaticEdge = edge;
										break;
									}
								}

								if (existingStaticEdge == null) {
									existingStaticEdge = graph.addEdge(enclosingClass, newClass);
									staticEdges.add(existingStaticEdge);
									graph.setEdgeWeight(existingStaticEdge, 0.0);
								}

								graph.setEdgeWeight(existingStaticEdge, 
										graph.getEdgeWeight(existingStaticEdge) + 1.0);

							} else {
								Set<DefaultWeightedEdge> edges = graph.getAllEdges(enclosingClass, newClass);
								DefaultWeightedEdge existingVirtualEdge = null;
								for (DefaultWeightedEdge edge : edges) {
									if (!staticEdges.contains(edge)) {
										existingVirtualEdge = edge;
										break;
									}
								}

								if (existingVirtualEdge == null) {
									existingVirtualEdge = graph.addEdge(enclosingClass, newClass);                           
									graph.setEdgeWeight(existingVirtualEdge, 0.0);
								}

								graph.setEdgeWeight(existingVirtualEdge, 
										graph.getEdgeWeight(existingVirtualEdge) + 1.0);
							}                        
						}

						if (!classToNewExprs.containsKey(newClass)) 
							classToNewExprs.put(newClass, new HashSet<NewExpr>());
						classToNewExprs.get(newClass).add(newExpr);
					}
				} else if (assign.getRightOp() instanceof NewArrayExpr) {
					//count new array exprs
					MutableInt count = reachableNewArrayExprs.get(enclosingClass);
					if (count == null) {
						reachableNewArrayExprs.put(enclosingClass, new MutableInt());
					}
					else {
						count.increment();
					}                                     
				}
			}

			//record string constants
			for (ValueBox vb : stmt.getUseAndDefBoxes()) {
				Value v = vb.getValue();
				if (v instanceof StringConstant) {
					if (!reachableStringConsts.containsKey(enclosingClass)) {
						reachableStringConsts.put(enclosingClass, new HashSet<String>());
					}
					reachableStringConsts.get(enclosingClass).add(((StringConstant)v).value);
				}
			}
		}
	}

	public Set<NewExpr> getNewExprsForClass(SootClass clz) {
		if (!classToNewExprs.containsKey(clz))
			return Collections.emptySet();
		return classToNewExprs.get(clz);
	}

	private  void buildAllocationGraph() {
		SootMethod[] methods = PTABridge.v().getReachableMethods().toArray(new SootMethod[0]);

		for (SootMethod method : methods) {
			updateAllocationGraph(method);  
		}
	}

	/**
	 * Once the allocation graph is built, this method returns an iteration over
	 * the graph that is in an order of increasing complexity of allocation complexity
	 * of soot class. 
	 */
	public List<SootClass> workList() {
		List<SootClass> trav = new LinkedList<SootClass>();

		List<SootClass> unvisited = new LinkedList<SootClass>();
		unvisited.addAll(graph.vertexSet());
		Collections.sort(unvisited, new SootClassComparator());



		for (SootClass clz : graph.vertexSet()) {
			/*
            if (graph.inDegreeOf(clz) == 0)
                unvisited.remove(clz);
			 */

			if (clz.isInterface())
				unvisited.remove(clz);
		}


		while (!unvisited.isEmpty()) {
			//find vertex with min number of incoming unvisited
			int min = Integer.MAX_VALUE;
			SootClass minVertex = null;

			for (SootClass clz : unvisited) {
				int incomingUnvisited = 0;
				for (DefaultWeightedEdge inEdge : graph.incomingEdgesOf(clz)) {
					if (unvisited.contains(graph.getEdgeSource(inEdge)))
						incomingUnvisited++;
				}

				//here we have a count of unvisited incoming
				//short circuit zero case
				if (incomingUnvisited == 0) {
					minVertex = clz;
					min = 0;
					break;
				} else if (incomingUnvisited < min) {
					min = incomingUnvisited;
					minVertex = clz;
				}
			}

			//at this point we have a clz with min number of incoming uncloned
			unvisited.remove(minVertex);
			trav.add(minVertex);
		}

		return trav;
	}

	public List<SootClass> breadthFirst() {
		List<SootClass> trav = new LinkedList<SootClass>();

		BreadthFirstIterator<SootClass, DefaultWeightedEdge> bf = 
				new BreadthFirstIterator<SootClass, DefaultWeightedEdge>(graph);

		while (bf.hasNext()) {
			trav.add(bf.next());
		}

		System.out.println("BFS traversal size: " + trav.size());

		return trav;
	}

	public void exportToDot(String filename) {
		DOTExporter<SootClass, DefaultWeightedEdge> dotE = new DOTExporter<SootClass, DefaultWeightedEdge>(
				new VertexNameProvider<SootClass>() {
					@Override
					public String getVertexName(SootClass arg0) {
						return arg0.hashCode() + "";
					}
				}, 
				new VertexNameProvider<SootClass>() {
					@Override
					public String getVertexName(SootClass arg0) {
						return arg0.getName();
					}
				},
				null);

		try {
			dotE.export(new FileWriter(filename), graph);
		} catch (IOException e) {
			logger.error("Error writing allocation graph dot file!");
			droidsafe.main.Main.exit(1);
		}
	}

	/**
	 * Compare soot classes based on their name.
	 * @author mgordon
	 *
	 */
	public class SootClassComparator implements Comparator<SootClass> {

		@Override
		public int compare(SootClass o1, SootClass o2) {
			return o1.getName().compareTo(o2.getName());
		}

	}
}
