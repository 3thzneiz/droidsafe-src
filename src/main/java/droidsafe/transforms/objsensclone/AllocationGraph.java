/*
 * Copyright (C) 2015,  Massachusetts Institute of Technology
 * 
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation; either version 2 of the License, or (at your
 * option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * for more details.
 * 
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc., 
 * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 * 
 * Please email droidsafe@lists.csail.mit.edu if you need additional
 * information or have any questions.
 */

package droidsafe.transforms.objsensclone;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Comparator;

import org.jgrapht.ext.DOTExporter;
import org.jgrapht.ext.VertexNameProvider;
import org.jgrapht.graph.DefaultEdge;
import org.jgrapht.graph.DirectedMultigraph;
import org.jgrapht.traverse.BreadthFirstIterator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import droidsafe.analyses.pta.PTABridge;
import droidsafe.android.app.Project;
import droidsafe.main.Config;
import droidsafe.utils.MutableInt;
import droidsafe.utils.SootUtils;
import soot.Body;
import soot.RefType;
import soot.Scene;
import soot.SootClass;
import soot.SootMethod;
import soot.Value;
import soot.ValueBox;
import soot.jimple.AssignStmt;
import soot.jimple.NewArrayExpr;
import soot.jimple.NewExpr;
import soot.jimple.Stmt;
import soot.jimple.StmtBody;
import soot.jimple.StringConstant;
import soot.util.Chain;

/**
 * A graph representing the allocation of a program.  Nodes are classes, and an edge from 
 * A->B denotes that class A creates a class B.  
 * 
 * The graph is used to clone classes in a particular order and introduce object sensitivity.
 * 
 * There are a few different methods that calculate different orderings for cloning.
 * 
 * @author mgordon
 *
 */
public class AllocationGraph {
    /** static logger class */
    private static final Logger logger = LoggerFactory.getLogger(AllocationGraph.class);
    /** the graph of allocation built on top of jgrapht. */
    private DirectedMultigraph<SootClass, DefaultEdge> graph;
    /** set of edges in the graph that are generated by static methods */
    private Set<DefaultEdge> staticEdges;
    /** map of soot class to the new expressions in reachable code that allocates the class */
    private Map<SootClass, Set<NewExpr>> classToNewExprs;
    /** map of class to number of new array expressions in reachable methods */    
    private Map<SootClass, MutableInt> reachableNewArrayExprs;
    /** map of class to string constants in reachable methods */    
    private Map<SootClass, Set<String>> reachableStringConsts;
    private Map<SootClass, Integer> complexityMap;

    /**
     * Create an allocation graph based on the current classes in the scene.
     */
    public AllocationGraph() {
        graph = new DirectedMultigraph<SootClass, DefaultEdge>(DefaultEdge.class);
        staticEdges = new HashSet<DefaultEdge>();
        classToNewExprs = new HashMap<SootClass, Set<NewExpr>>();
        reachableNewArrayExprs = new HashMap<SootClass, MutableInt>();
        reachableStringConsts = new HashMap<SootClass, Set<String>>();
        complexityMap = new HashMap<SootClass, Integer>();
        buildAllocationGraph();
        createComplexityMap();


        /*exportToDot(Project.v().getOutputDir() + File.separator + 
            "allocation-graph.dot");*/

        //System.out.println("Allocation graph size: " + graph.vertexSet().size());

        /*
        for (SootClass clz : workList()) {
            System.out.println(clz);
        }

        System.out.println("*************");
         */
    }

    public String getGraphStats() {
        long totalInDegree = 0;
        long numberGT1 = 0;
        for (SootClass clz : graph.vertexSet()) {
            if (graph.inDegreeOf(clz) > 1)
                numberGT1 ++;
            totalInDegree += graph.inDegreeOf(clz);
        }

        return "Number of nodes with in-degree > 1: " + numberGT1 +
                "\nAverage in-degree: " + (((double)totalInDegree) / ((double)graph.vertexSet().size()));
    }

    public int getInDegree(SootClass clz) {
        if (graph.containsVertex(clz))
            return graph.inDegreeOf(clz);
        return 0;
    }

    public int getOutDegree(SootClass clz) {
        if (graph.containsVertex(clz))
            return graph.outDegreeOf(clz);
        return 0;
    }

    //remove all edges from / to class that are not static
    public void removeClass(SootClass clz) {
        List<DefaultEdge> toRemove = new LinkedList<DefaultEdge>();
        for (DefaultEdge e : graph.edgesOf(clz)) {
            if (!staticEdges.contains(e)) 
                toRemove.add(e);
        }

        for (DefaultEdge e : toRemove) {
            graph.removeEdge(e);
        }
    }

    private int getArrayAndStringConstComplexity(SootClass clz) {
        return (reachableStringConsts.get(clz) == null ? 0 :
            reachableStringConsts.get(clz).size()) +
            (reachableNewArrayExprs.get(clz) == null ? 0 :
                reachableNewArrayExprs.get(clz).value());

    }

    private int getChildComplexity(SootClass current, int distanceFromStart, int k) {
        if (distanceFromStart >= (k - 1))
            return 1;

        int sum = getArrayAndStringConstComplexity(current);

        for (DefaultEdge edge : graph.outgoingEdgesOf(current)) {
            SootClass target = graph.getEdgeTarget(edge);
            sum += getChildComplexity(target, distanceFromStart + 1, k);
        }

        return sum;
    }

    private int calcComplexity(SootClass clz) {
        int k = Config.v().kobjsens;

        int childComplexity = getChildComplexity(clz, 0, k);

        int myComplexity = getArrayAndStringConstComplexity(clz);

        return graph.inDegreeOf(clz) * (childComplexity + myComplexity);
    }


    public int getComplexity(SootClass clz) {
        return complexityMap.get(clz);
    }

    public Map<SootClass, Integer> getComplexityMap() {
        return complexityMap;
    }

    private void createComplexityMap() {
        for (SootClass clz : graph.vertexSet()) {
            complexityMap.put(clz, calcComplexity(clz));                
        }
    }

    public void dumpComplexity() {
        try (FileWriter fw = new FileWriter(Project.v().getOutputDir() + File.separator + "alloc-complexity.csv")){
            for (SootClass clz : graph.vertexSet()) {
                fw.write(clz + "," + complexityMap.get(clz) + "\n");                
            }

        } catch (IOException e) {

        }
    }

    private void updateAllocationGraph(SootMethod method) {
        try {
            if (method.isAbstract() || !method.isConcrete())
                return;

            SootClass enclosingClass = method.getDeclaringClass();

            Body body = method.getActiveBody();
            StmtBody stmtBody = (StmtBody)body;
            Chain units = stmtBody.getUnits();
            Iterator stmtIt = units.snapshotIterator();

            while (stmtIt.hasNext()) {
                Stmt stmt = (Stmt)stmtIt.next();

                if (stmt instanceof AssignStmt) {
                    AssignStmt assign = (AssignStmt) stmt;
                    if (assign.getRightOp() instanceof NewExpr) {
                        NewExpr newExpr = (NewExpr)assign.getRightOp();
                        SootClass newClass = newExpr.getBaseType().getSootClass();
                        //is exception?
                        if (!SootUtils.isSubTypeOfIncluding(RefType.v(newClass), RefType.v("java.lang.Throwable"))) {
                            graph.addVertex(enclosingClass);
                            graph.addVertex(newClass);
                            DefaultEdge edge = graph.addEdge(enclosingClass, newClass);
                            if (method.isStatic()) {
                                staticEdges.add(edge);
                            }
                            if (!classToNewExprs.containsKey(newClass)) 
                                classToNewExprs.put(newClass, new HashSet<NewExpr>());
                            classToNewExprs.get(newClass).add(newExpr);
                        }
                    } else if (assign.getRightOp() instanceof NewArrayExpr) {
                        //count new array exprs
                        MutableInt count = reachableNewArrayExprs.get(enclosingClass);
                        if (count == null) {
                            reachableNewArrayExprs.put(enclosingClass, new MutableInt());
                        }
                        else {
                            count.increment();
                        }                                     
                    }
                }

                //record string constants
                for (ValueBox vb : stmt.getUseAndDefBoxes()) {
                    Value v = vb.getValue();
                    if (v instanceof StringConstant) {
                        if (!reachableStringConsts.containsKey(enclosingClass)) {
                            reachableStringConsts.put(enclosingClass, new HashSet<String>());
                        }
                        reachableStringConsts.get(enclosingClass).add(((StringConstant)v).value);
                    }
                }
            }
        } catch (Exception e) {
            logger.debug("Ignoring error while updating Allocation graph: ", e);
        }
    }

    public Set<NewExpr> getNewExprsForClass(SootClass clz) {
        if (!classToNewExprs.containsKey(clz))
            return Collections.emptySet();
        return classToNewExprs.get(clz);
    }

    private  void buildAllocationGraph() {
        //SootMethod[] methods = PTABridge.v().getReachableMethods().toArray(new SootMethod[0]);

        for (SootClass clz : Scene.v().getClasses()) {
            for (SootMethod method : clz.getMethods()) {
                updateAllocationGraph(method);  
            }
        }
    }

    /**
     * Once the allocation graph is built, this method returns an iteration over
     * the graph that is in an order of increasing complexity of allocation complexity
     * of soot class. 
     */
    public List<SootClass> workList() {
        List<SootClass> trav = new LinkedList<SootClass>();

        List<SootClass> unvisited = new LinkedList<SootClass>();
        unvisited.addAll(graph.vertexSet());
        Collections.sort(unvisited, new SootClassComparator());



        for (SootClass clz : graph.vertexSet()) {
            /*
            if (graph.inDegreeOf(clz) == 0)
                unvisited.remove(clz);
             */

            if (clz.isInterface())
                unvisited.remove(clz);
        }


        while (!unvisited.isEmpty()) {
            //find vertex with min number of incoming unvisited
            int min = Integer.MAX_VALUE;
            SootClass minVertex = null;

            for (SootClass clz : unvisited) {
                int incomingUnvisited = 0;
                for (DefaultEdge inEdge : graph.incomingEdgesOf(clz)) {
                    if (unvisited.contains(graph.getEdgeSource(inEdge)))
                        incomingUnvisited++;
                }

                //here we have a count of unvisited incoming
                //short circuit zero case
                if (incomingUnvisited == 0) {
                    minVertex = clz;
                    min = 0;
                    break;
                } else if (incomingUnvisited < min) {
                    min = incomingUnvisited;
                    minVertex = clz;
                }
            }

            //at this point we have a clz with min number of incoming uncloned
            unvisited.remove(minVertex);
            trav.add(minVertex);
        }

        return trav;
    }

    public List<SootClass> breadthFirst() {
        List<SootClass> trav = new LinkedList<SootClass>();

        BreadthFirstIterator<SootClass, DefaultEdge> bf = 
                new BreadthFirstIterator<SootClass, DefaultEdge>(graph);

        while (bf.hasNext()) {
            trav.add(bf.next());
        }

        System.out.println("BFS traversal size: " + trav.size());

        return trav;
    }

    public void exportToDot(String filename) {
        DOTExporter<SootClass, DefaultEdge> dotE = new DOTExporter<SootClass, DefaultEdge>(
                new VertexNameProvider<SootClass>() {
                    @Override
                    public String getVertexName(SootClass arg0) {
                        return arg0.hashCode() + "";
                    }
                }, 
                new VertexNameProvider<SootClass>() {
                    @Override
                    public String getVertexName(SootClass arg0) {
                        return arg0.getName();
                    }
                },
                null);

        try {
            dotE.export(new FileWriter(filename), graph);
        } catch (IOException e) {
            logger.error("Error writing allocation graph dot file!");
            droidsafe.main.Main.exit(1);
        }
    }

    /**
     * Compare soot classes based on their name.
     * @author mgordon
     *
     */
    public class SootClassComparator implements Comparator<SootClass> {

        @Override
        public int compare(SootClass o1, SootClass o2) {
            return o1.getName().compareTo(o2.getName());
        }

    }
}
